#include "complier_lib.h"

///////////////////////////////////////////////////////////////////////////////
//////函		数： 
//////功		能： 
//////输入参数: 
//////输出参数: 
//////说		明： 
//////////////////////////////////////////////////////////////////////////////
UINT8_T HexToBcd(UINT8_T hexVal)
{
	UINT8_T _return = 0;
	_return = (hexVal % 10 + (hexVal / 10) * 16);
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数： 
//////功		能： 
//////输入参数: 
//////输出参数: 
//////说		明： 
//////////////////////////////////////////////////////////////////////////////
UINT8_T BcdToDec(UINT8_T bcdVal)
{
	UINT8_T _return =(bcdVal >> 4);
	_return = (_return * 10 + (bcdVal & 0x0F));
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数： 
//////功		能： 
//////输入参数: 
//////输出参数: 
//////说		明： 
//////////////////////////////////////////////////////////////////////////////
UINT8_T DecToBcd(UINT8_T decVal)
{
	UINT8_T _return = (decVal / 10);
	_return = ((_return << 4) + ((decVal % 10) & 0x0F));
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数： 
//////功		能： 
//////输入参数: 
//////输出参数: 
//////说		明： 
//////////////////////////////////////////////////////////////////////////////
UINT8_T CalcCheckSum(UINT8_T *pVal, UINT16_T length)
{
	UINT16_T i = 0;
	UINT8_T _return = 0;
	for (i=0;i<length;i++)
	{
		_return += pVal[i];
	}
	//---计算的校验和
	_return = (UINT8_T)(0x100 - _return);
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数： 
//////功		能： 冒泡升序排列数据
//////输入参数: 
//////输出参数: 
//////说		明： 
//////////////////////////////////////////////////////////////////////////////
UINT8_T AscSortFun1(UINT8_T *pVal, UINT16_T length)
{
	UINT16_T i = 0;
	UINT16_T j = 0;
	UINT16_T k = length - 1;
	UINT16_T m = 0;
	UINT8_T flag;
	UINT8_T tmp;
	//---用k来保存新的判断条件
	for (i = 0;i<k;i++)
	{
		//---flag初始化为0
		flag = 0;
		m = 0;
		//---每排序一趟，则至少有一个元素已经有序，用 j<length-i-1 可以缩小排序范围
		for (j = 0;j<(length - 1 - i);j++)
		{
			//---当前面的元素大于后面的元素时，交换位置
			if (pVal[j]>pVal[j + 1])
			{
				tmp = pVal[j];
				pVal[j] = pVal[j + 1];
				pVal[j + 1] = tmp;
				//---若程序进入if语句,则必然会发生交换，当发生交换时把flag置成 1 
				flag = 1;
				//---记住最后一次交换的位置
				m = j;
			}
		}
		//---判断,如果flag=0，说明上一趟排序没有发生交换，数列已经有序，break
		if (flag == 0)
		{
			break;
		}
		//---将新的长度赋值给k
		k = m;
	}
	return 0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数： 
//////功		能： 
//////输入参数: 
//////输出参数: 
//////说		明： 
//////////////////////////////////////////////////////////////////////////////
UINT8_T AscSortFun2(UINT16_T *pVal, UINT16_T length)
{
	UINT16_T i = 0;
	UINT16_T j = 0;
	UINT16_T k = length - 1;
	UINT16_T m = 0;
	UINT8_T flag;
	UINT16_T tmp;
	//---用k来保存新的判断条件
	for (i = 0;i < k;i++)
	{
		//---flag初始化为0
		flag = 0;
		m = 0;
		//---每排序一趟，则至少有一个元素已经有序，用 j<length-i-1 可以缩小排序范围
		for (j = 0;j < (length - 1 - i);j++)
		{
			//---当前面的元素大于后面的元素时，交换位置
			if (pVal[j] > pVal[j + 1])
			{
				tmp = pVal[j];
				pVal[j] = pVal[j + 1];
				pVal[j + 1] = tmp;
				//---若程序进入if语句,则必然会发生交换，当发生交换时把flag置成 1 
				flag = 1;
				//---记住最后一次交换的位置
				m = j;
			}
		}
		//---判断,如果flag=0，说明上一趟排序没有发生交换，数列已经有序，break
		if (flag == 0)
		{
			break;
		}
		//---将新的长度赋值给k
		k = m;
	}
	return 0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数： 
//////功		能： 冒泡降序排列数据
//////输入参数: 
//////输出参数: 
//////说		明： 
//////////////////////////////////////////////////////////////////////////////
UINT8_T DescSortFun1(UINT8_T *pVal, UINT16_T length)
{
	UINT16_T i = 0;
	UINT16_T j = 0;
	UINT16_T k = length - 1;
	UINT16_T m = 0;
	UINT8_T flag;
	UINT8_T tmp;
	//---用k来保存新的判断条件
	for (i = 0;i < k;i++)
	{
		//---flag初始化为0
		flag = 0;
		m = 0;
		//---每排序一趟，则至少有一个元素已经有序，用 j<length-i-1 可以缩小排序范围
		for (j = 0;j < (length - 1 - i);j++)
		{
			//---当前面的元素大于后面的元素时，交换位置
			if (pVal[j] < pVal[j + 1])
			{
				tmp = pVal[j];
				pVal[j] = pVal[j + 1];
				pVal[j + 1] = tmp;
				//---若程序进入if语句,则必然会发生交换，当发生交换时把flag置成 1 
				flag = 1;
				//---记住最后一次交换的位置
				m = j;
			}
		}
		//---判断,如果flag=0，说明上一趟排序没有发生交换，数列已经有序，break
		if (flag == 0)
		{
			break;
		}
		//---将新的长度赋值给k
		k = m;
	}
	return 0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数： 
//////功		能： 冒泡降序排列数据
//////输入参数: 
//////输出参数: 
//////说		明： 
//////////////////////////////////////////////////////////////////////////////
UINT8_T DescSortFun2(UINT16_T *pVal, UINT16_T length)
{
	UINT16_T i = 0;
	UINT16_T j = 0;
	UINT16_T k = length - 1;
	UINT16_T m = 0;
	UINT8_T flag;
	UINT16_T tmp;
	//---用k来保存新的判断条件
	for (i = 0;i < k;i++)
	{
		//---flag初始化为0
		flag = 0;
		m = 0;
		//---每排序一趟，则至少有一个元素已经有序，用 j<length-i-1 可以缩小排序范围
		for (j = 0;j < (length - 1 - i);j++)
		{
			//---当前面的元素大于后面的元素时，交换位置
			if (pVal[j] < pVal[j + 1])
			{
				tmp = pVal[j];
				pVal[j] = pVal[j + 1];
				pVal[j + 1] = tmp;
				//---若程序进入if语句,则必然会发生交换，当发生交换时把flag置成 1 
				flag = 1;
				//---记住最后一次交换的位置
				m = j;
			}
		}
		//---判断,如果flag=0，说明上一趟排序没有发生交换，数列已经有序，break
		if (flag == 0)
		{
			break;
		}
		//---将新的长度赋值给k
		k = m;
	}
	return 0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数： 
//////功		能： 
//////输入参数: 
//////输出参数: 
//////说		明： 
//////////////////////////////////////////////////////////////////////////////
UINT16_T CalcAvgFun1(UINT16_T *pVal, UINT16_T length,UINT16_T index)
{
	double sum = 0;
	UINT16_T i = 0;
	for (i=index;i<length;i++)
	{
		sum += pVal[i];
	}
	return (UINT16_T)(sum / (length - index));
}

///////////////////////////////////////////////////////////////////////////////
//////函		数： 
//////功		能： 
//////输入参数: 
//////输出参数: 
//////说		明： 
//////////////////////////////////////////////////////////////////////////////
UINT16_T CalcAvgFun2(UINT16_T *pVal, UINT16_T length)
{
	double sum = 0;
	UINT16_T i = 0;
	for (i = 0;i < length;i++)
	{
		sum += pVal[i];
	}
	return (UINT16_T)(sum / length);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数： 
//////功		能： 
//////输入参数: 
//////输出参数: 
//////说		明： 
//////////////////////////////////////////////////////////////////////////////
UINT8_T CalcAvgFun3(UINT8_T *pVal, UINT16_T length, UINT16_T index)
{
	double sum = 0;
	UINT16_T i = 0;
	for (i = index;i < length;i++)
	{
		sum += pVal[i];
	}
	return (UINT8_T)(sum / (length - index));
}

///////////////////////////////////////////////////////////////////////////////
//////函		数： 
//////功		能： 
//////输入参数: 
//////输出参数: 
//////说		明： 
//////////////////////////////////////////////////////////////////////////////
UINT16_T CalcAvgFun4(UINT8_T *pVal, UINT16_T length)
{
	double sum = 0;
	UINT16_T i = 0;
	for (i = 0;i < length;i++)
	{
		sum += pVal[i];
	}
	return (UINT8_T)(sum / length);
}

///////////////////////////////////////////////////////////////////////////////
//////函	   数： 
//////功	   能： 
//////输入参数: 
//////输出参数: 0---相等；1---不相等
//////说	   明： 
//////////////////////////////////////////////////////////////////////////////
UINT8_T CompareFun1(UINT8_T *p1,UINT8_T *p2,UINT16_T length)
{
	UINT16_T i=0;
	for (i=0;i<length;i++)
	{
		if (p1[i]!=p2[i])
		{
			return 1;
		}
	}
	return 0;
}

///////////////////////////////////////////////////////////////////////////////
//////函	   数： 
//////功	   能： 
//////输入参数: 
//////输出参数: 0---相等；1---不相等
//////说	   明： 指定比较数据的起始位置
//////////////////////////////////////////////////////////////////////////////
UINT8_T CompareFun2(UINT8_T *p1,UINT8_T *p2,UINT16_T index,UINT16_T length)
{
	UINT16_T i=0;
	for (i=index;i<length;i++)
	{
		if (p1[i]!=p2[i])
		{
			return 1;
		}
	}
	return 0;
}

///////////////////////////////////////////////////////////////////////////////
//////函	   数： 
//////功	   能： 
//////输入参数: 
//////输出参数: 0---相等；1---不相等
//////说	   明： 
//////////////////////////////////////////////////////////////////////////////
UINT8_T CompareFun3(UINT16_T *p1,UINT16_T *p2,UINT16_T length)
{
	UINT16_T i=0;
	for (i=0;i<length;i++)
	{
		if (p1[i]!=p2[i])
		{
			return 1;
		}
	}
	return 0;
}

///////////////////////////////////////////////////////////////////////////////
//////函	   数： 
//////功	   能： 
//////输入参数: 
//////输出参数: 0---相等；1---不相等
//////说	   明： 指定比较数据的起始位置
//////////////////////////////////////////////////////////////////////////////
UINT8_T CompareFun4(UINT16_T *p1,UINT16_T *p2,UINT16_T index,UINT16_T length)
{
	UINT16_T i=0;
	for (i=index;i<length;i++)
	{
		if (p1[i]!=p2[i])
		{
			return 1;
		}
	}
	return 0;
}